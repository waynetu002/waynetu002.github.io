---

layout: post
title: ssl证书是什么东西
category: 技术
tags: WEB
keywords: ssl

---

## 简介 

* TOC
{:toc}

1981年，今天互联网共同遵守的网络规则“TCP/IP协议”诞生。以传输控制协议（TCP）和网际协议（IP）为主的设计则提供了一套标准化的通信规则，使得不同厂商的设备以及不同网络能够互联互通。有了这样统一“接口”的基础，1989年，后来被称为“互联网之父”的蒂姆·伯纳斯 - 李（Tim Berners-Lee）提出了在互联网上构建超链接文档系统的构想，HTTP（超文本传输协议）诞生。它让通过TCP/IP协议统一了交流语言的机器们，可以通过互联网实现全球范围更广泛的互通。但事实上，在互联网的故事里，HTTP之后，互联网距离真正的繁荣还差关键一环，就是协议之上的安全标准。HTTP们打下规模化的基础后，问题也随之产生——它是一个明文传输的协议，这暴露了严重的安全问题。例如，用户输入的信用卡信息在传输时可能被黑客窃听，或网页内容被篡改破坏了安全。为此，网景公司（Netscape）于1994年开发了SSL（安全套接层）协议，并推出了HTTPS（超文本传输安全协议），在HTTP的基础上加入了SSL，保护传输安全。

[Java 和 HTTP 的那些事（四） HTTPS 和 证书](http://www.aneasystone.com/archives/2016/04/java-and-https.html)

安全的通信有以下要求

1. 通信双方可信：是自己人；发了不能抵赖。主要在握手阶段完成。
2. 内容不被篡改：我发给他的消息是加密的你截了没用，你无法换你自己的，换成你自己的他就不认识，解不开。
3. 内容不可见

## TLS

TLS包括两部分：TLS 记录协议和 TLS 握手协议。TLS 记录协议主要保证传输过程中信息传输的完整性和私密性，这一部分通过协商后的密钥来加密数据。TLS 握手协议主要是为了认证对方的身份、协商密钥。

TLS 是先完成握手，然后进行加密通信。非对称算法用于交换随机数等信息，以便生成对称密钥；对称算法用于信息的加解密。在握手阶段，TLS 需要四类算法的参与，分别是：
1. 密钥交换算法，保证对称密钥的交换是安全的，典型算法包括 DHE、ECDHE。
2. 身份验证和签名算法，确认服务端的身份，其实就是对证书的验证，非对称算法就用在这里。典型算法包括 RSA、ECDSA。
3. 对称加密算法，对应用层数据进行加密，典型算法包括 AES、DES。
4. 消息完整性校验算法。：确保消息不被篡改，典型算法包括 SHA1、SHA256。
这四类算法的组合，就形成了密码套件，英文叫 Cipher Suite。一个典型的密码套件：TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA（0xc013）
1. TLS 不用多说，代表了 TLS 协议。
2. ECDHE 是密钥交换算法，双方通过它就不用直接传输对称密钥，而只需通过交换双方生成的随机数等信息，就可以各自计算出对称密钥。
3. RSA 是身份验证和签名算法，主要是客户端来验证服务端证书的有效性，确保服务端是本尊，非假冒。
4. AES128_CBC 是对称加密算法，应用层的数据就是用这个算法来加解密的。这里的 CBC 属于块式加密模式，另外一类模式是流式加密。
5. SHA 就是最后的完整性校验算法（哈希算法）了，它用来保证密文不被篡改。
6. 0xc013 呢，是这个密码套件的编号，每种密码套件都有独立的编号。完整的编号列表在 [IANA 的网站](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml)上可以找到。

在不同的客户端和服务端软件上，这些密码套件也各不相同。所以，TLS 握手的重要任务之一，就是找到双方共同支持的那个密码套件，也就是找到大家的“共同语言”，如果无法协商出公用的密码套件，握手就必定会失败。比如`javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure`

对 TLS 相关问题的排查，也就面临着两类问题：
1. 一类是 TLS 握手阶段的问题，引起这个问题的原因还是比较多的，比如域名不匹配、证书过期等等。不过，这些问题一般都可以通过“忽略验证”这个简单的操作来跳过。在 Wireshark 里可以导出 Cipher Suite。
2. 一类是 TLS 通信过程中的问题。

TLS 只是一套协议，具体的活当然还是代码来干。目前应用最为广泛的 SSL/TLS 实现可能就是 OpenSSL 了，它既是一个开发库，也是一个命令行工具的名称。应用程序会基于这些 TLS 库来实现 TLS 加解密功能。

![](/public/upload/network/openssl.png)

`curl -vk https://站点名` -k 会跳过对服务器证书的验证

## 证书

### 受数字签名保护的文档

一个受数字签名保护的文档可示意如下

![](/public/upload/web/signature_document.png)

1. “要防篡改的内容” 是信息原文。
2. “密钥提示” 是在数字签名的 “密钥” 有多个的情况下，通过 “密钥提示” 找到对应的 “密钥”。如果用于保护信息的 “密钥” 只有一个，那么可以没有 “密钥提示”。
3. “指纹” 则是对信息使用特定 “密钥” 和信息摘要算法生成的信息摘要。

许式伟：为了彻底阻止木马程序篡改正常的应用程序，聪明的操作系统创造者们想到了好方法：数字签名。**这本质上是白名单技术。所有正常发布的软件都到操作系统厂商那里登记一下**。这样，一旦木马去修改软件，把自己附加上去（把自己加到一个正常程序的尾部，然后修改程序入口，让它跳转到自己，执行完自己后再跳转回正常的程序代码。这样在用户看来这个程序功能没有发生变化，但是实际上每次开始的时候都会先运行病毒/木马程序再运行正常功能代码），这个软件的签名验证就通不过，也就直接暴露了。第一个大规模把软件发布变成一个封闭环境的是苹果的 iOS 操作系统。苹果通过引入 App Store，要求所有应用发布都必须通过 App Store 进行。这样一来，软件无法被非法修改，木马基本上就无所遁形了。当然，这并不代表木马在这些平台上就消失了。

### 为什么需要证书？——安全的分发公钥

[数字证书原理](http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html)逻辑链条：

1. 加密由加密算法 + 密钥组成，加密算法公开，于是**密钥分发成了关键。**（可以试想，若是加密算法私有，自然就没有密钥分发及之后的问题，代之就只加密算法本身的安全问题）
2. 对称加密密钥不易分发，也**不能每次都一样**
3. 非对称加密通信，客户端持有服务端的公钥，但**服务商的公钥谁都可以得到**，服务商给我发的消息，别人虽然不能改，但也可以截获并解密。
4. 所以，**纯粹的对称加密 和 非对称加密 都是无法做到安全通信的**。因此，先使用非对称加密 约定一个对称密钥，再用对称加密交流
5. 问题就变成了：客户端如何拿到服务商的公钥？ ==> 服务商的公钥如何安全的在网络上传输呢？==> 服务商不直接分发公钥，而是分发经CA私钥加密过的数字证书（包含公钥+服务商域名等信息）。客户端持有CA的公钥，解密后拿到服务商的公钥。

    从概念上来讲，数字证书是用来验证网络通信参与者的一个文件。这**和学校颁发 给学生的毕业证书类似**。在学校和学生之间，**学校是可信第三方 CA**，而学生是通信 参与者。如果社会普遍信任一个学校的声誉的话，那么这个学校颁发的毕业证书，也 会得到社会认可。参与者证书和 CA 证书可以类比毕业证和学校的办学许可证。

6. CA的公钥如何安全的在网络上传输呢？给CA 也颁发证书，然后大家都无条件信任root CA，在操作系统、浏览器发布的时候便嵌入了root CA。
    
    ![](/public/upload/apache/ca_tree.png)

就好比谍报战里的接头戏码

1. 两个彼此认识的特工接头会轻松一点，双方可能会经常变换下接头方式
2. 第一次跟新来的特工接头，上级会告诉你xx点去xx等一个手里拿着xx的人，接头暗号是“hello/world”。此次，双方都认识的上级是CA，“hello/world” 便是对方的CA证书。

### 证书

1. 证书有什么，Chrome可以通过"settings ==> advanced setting ==> https/ssl ==> 管理证书" 查看证书内容。证书基本上是一个文本文件。

	* 服务商的公钥
	* 服务商的信息
	* 对上述信息算一个签名，用ca自己的私钥加密一下
	
2. 如何验证证书？我拥有ca的公钥，对证书上的信息做一个签名， 解密证书上的签名，比对。

	* 如果两个签名一样，签名一样，说明证书没被篡改
	* 签名可以用ca公钥正确解密，说明是用ca私钥加密的，即证书是ca颁发的

	结论，证书是可信的，那么证书上的内容，尤其是服务商的公钥是可信的。就好像，毕业证上学校公章是可信的，那么可以相信这个学生的学历是可信的。

TLS 的信任是通过对证书链的验证：信任根证书 -> 信任中间证书 -> 信任叶子证书。本地证书加上收到的证书，就形成了证书链，如果其中有问题，那么证书校验将会失败

### 动态加载证书

大多数时候，本地只要有常用的ca根证书，即可验证大部分服务商。证书被验证可信后，浏览器或操作系统会将证书存储在本地（证书有效期内），当用户在浏览器中键入https地址时，直接开始同服务端商定对称算法和密钥，从而省去证书的获取和验证过程。

但是，当服务商证书不在Java 的 cacerts 文件中，或者无法通过ca证书链式推导，我们也可以手动添加。
 
 1. 12306之类的网站，证书基本可信，但不是向ca申请的
 2. 内部通信，证书自己生成，自己确认可信

添加方式

1. 使用java keytool工具添加。有时候不具备权限，或要添加的机器过多
2. 程序加载。这就是一些应用在使用时，要指定证书地址的缘故了。应用作为客户端，直接加载服务端证书，以省去证书验证过程。

### 证书的存储

浏览器保存了一个常用的 CA 证书列表，与此类似的，操作系统也一样保存有一份可信的证书列表。Java 在 JRE 的安装目录下也保存了一份默认可信的证书列表，可以使用 JRE 自带的 keytool 工具.

	/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/security
	---	cacerts

证书的格式

CA 在发布证书时，常常使用 PEM 格式，这种格式的好处是纯文本，内容是 BASE64 编码的，另外还有比较常用的二进制 DER 格式，在 Windows 平台上较常使用的 PKCS#12 格式等等。当然，不同格式的证书之间是可以相互转换的。

在 Java 平台下，证书常常被存储在 KeyStore 文件中，上面说的 cacerts 文件就是一个 KeyStore 文件（KeyStore 只是一种文件格式，java中使用keyStore文件存储加密相关的数据，证书是其中一种）。存储在 KeyStore 文件中的对象有三种类型：Certificate、PrivateKey 和 SecretKey 。
1. Certificate 就是证书，
2. PrivateKey 是非对称加密中的私钥，
3. SecretKey 用于对称加密，是对称加密中的密钥。

KeyStore 文件根据用途，也有很多种不同的格式：JKS、JCEKS、PKCS12、DKS 等等。

java中的keyStore文件根据用途，分为两类：keyStore、TrustStore，对应两个类 KeyManager 和 TrustManager。前者负责管理自己的私钥等数据，后者负责存储一些可信任的证书。可以想见，如果我们改写 TrustManager 类，让其无论何时都返回true，即可绕过对证书的验证。

### 制作证书

||文件后缀|备注|
|---|---|---|
|证书签名请求(Certificate signing request) |`*.csr`|包含域名、国家、城市、公司、邮箱等信息|
|私钥(Private Key) | `*.key`|
|证书(Certificate) | `*.cer` ,`*.crt`|CA 使用其私钥对 csr签名生成crt|

至于pem和der(少见)是编码方式，以上三类（Cert,Key,CSR）均可以使用这两种编码方式。
1. `*.pem` - base64编码
2. `*.der` - 二进制编码

[TLS/HTTPS 证书生成与验证](http://www.cnblogs.com/kyrios/p/tls-and-certificates.html)

[基于OpenSSL自建CA和颁发SSL证书](seanlook.com/2015/01/18/openssl-self-sign-ca/)

假设自己的nginx 对外提供https支持

1. 自建ca 或第三方ca 机构
2. 在nginx 机器上 创建一对儿rsa密钥（key文件）；生成证书请求（csr文件）
3. 将csr文件发送到ca服务器（第三方ca机构），得到nginx crt证书（crt或pem后缀）
4. 访问nginx 的客户端持有ca 根crt证书，持有或获取 nginx 的crt 证书，即可与nginx 进行https通讯。

### ca和pki

1. 基于私钥加密，只能使用公钥解密：起到身份认证的作用。
2. 公钥的管理：PKI 公钥基础设施
    1. 由CA 数字证书认证机构将用户个人身份与公开秘钥关联在一起。 PS：**就好像微博认证xx 账号是xx，所以我们可以相信xx账号发的内容是xx 发的**。
    2. 公钥数字证书组成：CA信息、公钥用户信息、公钥、权威结构的签字、有效期。

所以呢，有一个PKI（Public Key Infrastructure）的概念，中文称作公钥基础设施。它提供公钥加密和数字签名服务的系统或平台，比如ca系统，浏览器和操作系统内置一些常用ca证书。通过协议和机制的约定，实现公钥的可信分发，进而建立起一个安全的网络环境。而数字证书最常见的格式是 X.509 ，所以这种公钥基础设施又称之为 PKIX 。

而在大公司内部，通常会建立私有的ca和pki体系。

## 安全应用

### ssh

[SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)

密码登陆

![](/public/upload/web/ssh_password_login.png)

如果嫌每次登陆输密码麻烦，可以公钥登陆

![](/public/upload/web/ssh_rsa_login.png)

### https

SSL/TLS 四次握手

![](/public/upload/web/tls_sequence_diagram.png)

总结一下https设计到的一些加密知识

1. 哈希，将任意长度的数据转化为固定长度的，验证数据是否被篡改
2. 对称加密，加密和解密使用同一个密钥，对称加密的优点是速度快，缺点是密钥管理不方便，必须共享密钥
3. 非对称加密，缺点是速度慢，**优点是双方无需共享同一个密钥，密钥管理很方便**。比如秘钥AB是一对秘钥，A或B泄露一个，最多可以偷看某个单向的消息，无法篡改后再发出（接收方会无法解锁），这就解决了内容被篡改的问题（内容泄漏没解决）。 
4. 数字证书，提供可信的服务商（CA 机构）公钥

### 其它

上文提到的都是单向非对称加密，对于安全性很高的场景（比如网银）， 不仅客户端要验证服务端的合法性，服务端也要验证每个访问的客户端的合法性，对于这种场景，往往给每个用户发一个U盘，里面装的就是客户端的公钥和私钥对，用于双向非对称加密。

![](/public/upload/apache/secret.png)
